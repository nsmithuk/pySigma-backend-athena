from typing import Any, ClassVar, Dict, Optional

from sigma.conversion.state import ConversionState
from sigma.correlations import (
    SigmaCorrelationRule,
    SigmaCorrelationTypeLiteral,
)
from sigma.exceptions import SigmaConversionError
from sigma.processing.pipeline import ProcessingPipeline
from sigma.rule import SigmaRule

from .base import athenaBaseBackend


class PartialFormatDict(dict):
    """A dictionary subclass that handles missing keys by returning the key name in curly braces."""

    def __missing__(self, key):
        return "{" + key + "}"


class athenaBackend(athenaBaseBackend):
    """
    With Correlation support
    """

    def __init__(
        self,
        processing_pipeline: Optional[ProcessingPipeline] = None,
        collect_errors: bool = False,
        **backend_options: Dict,
    ):
        """
        Initialize the Athena backend.

        Args:
            processing_pipeline: Optional processing pipeline to apply transformations to Sigma rules.
            collect_errors: If True, collect errors during conversion instead of raising them.
            table: Optional, the name of the table to include in the SQL statement.
            fields: Optional, the name of the fields to select in the SQL statement. Defaults to *.
            **backend_options: Additional backend-specific options.
        """
        super().__init__(processing_pipeline, collect_errors, **backend_options)

        self._time_field: str = backend_options.get("time_field") or "time"

    # The default field (column) name that contains the row's timestamp.
    default_time_field: ClassVar[str] = "time_dt"

    correlation_methods: ClassVar[Dict[str, str]] = {
        "default": "Default method",
    }

    ### Correlation rule templates
    ## Correlation query frame
    # The correlation query frame is the basic structure of a correlation query for each correlation
    # type. It contains the following placeholders:
    # * {search} is the search expression generated by the correlation query search phase.
    # * {typing} is the event typing expression generated by the correlation query typing phase.
    # * {aggregate} is the aggregation expression generated by the correlation query aggregation
    #   phase.
    # * {condition} is the condition expression generated by the correlation query condition phase.
    # If a correlation query template for a specific correlation type is not defined, the default correlation query template is used.
    default_correlation_query: ClassVar[Optional[Dict[str, str]]] = None

    event_count_correlation_query: ClassVar[Optional[Dict[str, str]]] = {
        "default": "WITH combined_events AS ({search}), event_counts AS ({aggregate}) {condition}"
        # "default": "WITH event_counts AS (SELECT {selectfields}, COUNT(*) OVER ({aggregate}) as event_count FROM {table} WHERE {search} ORDER BY {timefield}) {condition}"
    }

    value_count_correlation_query: ClassVar[Optional[Dict[str, str]]] = None

    # Trino does not support COUNT(DISTINCT {field}) with OVER, yet.
    # value_count_correlation_query: ClassVar[Optional[Dict[str, str]]] = {
    #      "default": "WITH value_counts AS (SELECT {selectfields}, COUNT(DISTINCT {field}) OVER ({aggregate}) as value_count FROM {table} WHERE {search} ORDER BY {timefield}) {condition}"
    # }

    temporal_correlation_query: ClassVar[Optional[Dict[str, str]]] = None
    temporal_ordered_correlation_query: ClassVar[Optional[Dict[str, str]]] = None

    ## Correlation query search phase
    # The first step of a correlation query is to match events described by the referred Sigma
    # rules. A main difference is made between single and multiple rule searches.
    # A single rule search expression defines the search expression emitted if only one rule is
    # referred by the correlation rule. It contains the following placeholders:
    # * {rule} is the referred Sigma rule.
    # * {ruleid} is the rule name or if not available the id of the rule.
    # * {query} is the query generated from the referred Sigma rule.
    # * {normalization} is the expression that normalizes the rule field names to unified alias
    #   field names that can be later used for aggregation. The expression is defined by
    #   correlation_search_field_normalization_expression defined below.

    # correlation_search_single_rule_expression: ClassVar[str] = "{query}" # We treat one or more rules in the sames way, so we'll always use the 'multi_rule' options.

    # If no single rule query expression is defined, the multi query template expressions below are
    # used and must be suitable for this purpose.

    # A multiple rule search expression defines the search expression emitted if multiple rules are
    # referred by the correlation rule. This is split into the expression for the query itself:
    correlation_search_multi_rule_expression: ClassVar[Optional[str]] = "{queries}"
    # This template contains only one placeholder {queries} which contains the queries generated
    # from single queries joined with a query separator:
    # * A query template for each query generated from the referred Sigma rules similar to the
    #   search_single_rule_expression defined above:
    correlation_search_multi_rule_query_expression: ClassVar[Optional[str]] = "{query}"
    #   Usually the expression must contain some an expression that marks the matched event type as
    #   such, e.g. by using the rule name or uuid.
    # * A joiner string that is put between each search_multi_rule_query_expression:
    correlation_search_multi_rule_query_expression_joiner: ClassVar[Optional[str]] = " UNION ALL "

    ## Correlation query aggregation phase
    # All of the following class variables are dictionaries of mappings from
    # correlation_method names to format strings with the following placeholders:
    # * {rule} contains the whole correlation rule object.
    # * {referenced_rules} contains the Sigma rules that are referred by the correlation rule.
    # * {field} contains the field specified in the condition.
    # * {timespan} contains the timespan converted into the target format by the convert_timespan
    #   method.
    # * {groupby} contains the group by expression generated by the groupby_* templates below.
    # * {search} contains the search expression generated by the correlation query search phase.
    event_count_aggregation_expression: ClassVar[Optional[Dict[str, str]]] = {
        # "default": "WITH event_counts AS (SELECT {selectfields}, COUNT(*) OVER ({over}) as event_count FROM {table} WHERE {search} ORDER BY {timefield})"
        # "default": "PARTITION BY {groupby} ORDER BY {timefield} RANGE BETWEEN INTERVAL '{timespan}' SECOND PRECEDING AND CURRENT ROW"
        "default": "SELECT *, COUNT(*) OVER (PARTITION BY {groupby} ORDER BY {timefield} RANGE BETWEEN INTERVAL '{timespan}' SECOND PRECEDING AND CURRENT ROW) as correlation_event_count FROM combined_events"
    }
    value_count_aggregation_expression: ClassVar[Optional[Dict[str, str]]] = {
        None  # Expression for temporal correlation rules
    }
    temporal_aggregation_expression: ClassVar[Optional[Dict[str, str]]] = (
        None  # Expression for temporal correlation rules
    )
    temporal_ordered_aggregation_expression: ClassVar[Optional[Dict[str, str]]] = (
        None  # Expression for ordered temporal correlation rules
    )

    # We'll just convert it to seconds; seems easier.
    timespan_seconds: ClassVar[bool] = (
        True  # If True, timespan is converted to seconds instead of using a more readable timespan specification like 5m.
    )

    # The following class variables defined the templates for the group by expression.
    groupby_expression: ClassVar[Dict[str, str]] = {"default": "{fields}"}
    groupby_field_expression: ClassVar[Dict[str, str]] = {"default": "{field}"}
    groupby_field_expression_joiner: ClassVar[Dict[str, str]] = {"default": ", "}

    ## Correlation query condition phase
    # The final correlation query phase adds a final filter that filters the aggregated events
    # according to the given conditions. The following class variables define the templates for the
    # different correlation rule types and correlation methods (dict keys).
    # Each template gets the following placeholders:
    # * {op} is the condition operator mapped according o correlation_condition_mapping.
    # * {count} is the value specified in the condition.
    # * {field} is the field specified in the condition.
    # * {referenced_rules} contains the Sigma rules that are referred by the correlation rule. This
    #   expression is generated by the referenced_rules_expression template in combination with the
    #   referenced_rules_expression_joiner defined above.
    event_count_condition_expression: ClassVar[Optional[Dict[str, str]]] = {
        "default": "SELECT * FROM event_counts WHERE correlation_event_count {op} {count}",
    }
    value_count_condition_expression: ClassVar[Optional[Dict[str, str]]] = {
        "default": "SELECT * FROM value_counts WHERE value_count {op} {count}",
    }
    temporal_condition_expression: ClassVar[Optional[Dict[str, str]]] = None
    temporal_ordered_condition_expression: ClassVar[Optional[Dict[str, str]]] = None

    # Correlation query conversion
    # The following methods are used to convert Sigma correlation rules into queries. The conversion
    # starts with the convert_correlation_rule method that calls correlation type specific methods
    # which itself call convert_correlation_rule_from_template that dispatches to the three
    # correlation query phases: search, aggregation and condition.
    def convert_correlation_rule_from_template(
        self,
        rule: SigmaCorrelationRule,
        correlation_type: SigmaCorrelationTypeLiteral,
        method: str,
    ) -> list[str]:
        template = (
            getattr(self, f"{correlation_type}_correlation_query")
            or self.default_correlation_query
        )
        if template is None:
            raise NotImplementedError(
                f"Correlation rule type '{correlation_type}' is not supported by backend."
            )

        if method not in template:
            raise SigmaConversionError(
                f"Correlation method '{method}' is not supported by backend for correlation type '{correlation_type}'."
            )

        search = self.convert_correlation_search(rule)
        aggregate = self.convert_correlation_aggregation_from_template(
            rule, correlation_type, method, search
        )
        condition = self.convert_correlation_condition_from_template(
            rule.condition, rule.rules, correlation_type, method
        )

        query = template[method].format_map(
            PartialFormatDict(
                timefield=self._time_field,
                search=search,
                aggregate=aggregate,
                condition=condition,
            )
        )
        # WITH combined_events AS ({search}), event_counts AS ({aggregate}) {condition}

        return [query]

    def convert_correlation_search(
        self,
        rule: SigmaCorrelationRule,
        **kwargs,
    ) -> str:
            return self.correlation_search_multi_rule_expression.format(
                queries=self.correlation_search_multi_rule_query_expression_joiner.join(
                    (
                        self.correlation_search_multi_rule_query_expression.format(
                            # rule=rule_reference.rule,
                            # ruleid=rule_reference.rule.name or rule_reference.rule.id,
                            queryx=self.convert_correlation_search_multi_rule_query_postprocess(
                                query
                            ),
                            query=self.athena_finalize_query_default(rule_reference.rule, query, rule_reference.rule.get_conversion_states()[0])
                            # normalization=self.convert_correlation_search_field_normalization_expression(
                            #     rule.aliases,
                            #     rule_reference,
                            # ),
                        )
                        for rule_reference in rule.rules
                        for query in rule_reference.rule.get_conversion_result()
                    )
                ),
                **kwargs,
            )

    # Implementation of the aggregation phase of the correlation query.
    def convert_correlation_aggregation_from_template(
        self,
        rule: SigmaCorrelationRule,
        correlation_type: SigmaCorrelationTypeLiteral,
        method: str,
        search: str,
    ) -> str:
        templates = getattr(self, f"{correlation_type}_aggregation_expression")
        if templates is None:
            raise NotImplementedError(
                f"Correlation type '{correlation_type}' is not supported by backend."
            )
        template = templates[method]

        aggregation = template.format(
            timefield=self._time_field,
            groupby=self.convert_correlation_aggregation_groupby_from_template(
                rule.group_by, method
            ),
            timespan=self.convert_timespan(rule.timespan, method),
        )
        # "PARTITION BY {groupby} ORDER BY {timefield} RANGE BETWEEN INTERVAL '{timespan}' SECOND PRECEDING AND CURRENT ROW"

        return aggregation

    def finalize_query_default(
        self, rule: SigmaRule, query: str, index: int, state: ConversionState
    ) -> Any:
        if not isinstance(rule, SigmaCorrelationRule):
            return super().finalize_query_default(rule, query, index, state)

        return query
